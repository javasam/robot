#define SCL_Pin  A5  // Set clock pin to A5
#define SDA_Pin  A4  // Set data pin to A4


// Битовые паттерны для символов (пример для букв A, B, C)
unsigned char A[16] = {0xfc, 0x22, 0x22, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char B[16] = {0xfe, 0x92, 0x92, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char C[16] = {0x7c, 0x82, 0x82, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char D[16] = {0xfe, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char E[16] = {0xfe, 0x92, 0x92, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char F[16] = {0xfe, 0x12, 0x12, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char G[16] = {0x7c, 0x82, 0x92, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char H[16] = {0xfe, 0x10, 0x10, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char I[16] = {0x00, 0x82, 0xfe, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char J[16] = {0x40, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char K[16] = {0xfe, 0x10, 0x28, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char L[16] = {0xfe, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char M[16] = {0xfe, 0x04, 0x08, 0x04, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char N[16] = {0xfe, 0x08, 0x10, 0x20, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char O[16] = {0x7c, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char P[16] = {0xfe, 0x12, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char Q[16] = {0x7c, 0x82, 0x42, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char R[16] = {0xfe, 0x12, 0x32, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char S[16] = {0x4c, 0x92, 0x92, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char T[16] = {0x02, 0x02, 0xfe, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char U[16] = {0x7e, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char V[16] = {0x3e, 0x40, 0x80, 0x40, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char W[16] = {0xfe, 0x40, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char X[16] = {0xc6, 0x28, 0x10, 0x28, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char Y[16] = {0x06, 0x08, 0xf0, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char Z[16] = {0xc2, 0xa2, 0x92, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned char space[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};



// Таблица символов
unsigned char* getCharPattern(char c) {
  switch (c) {
    case 'A': return A;
    case 'B': return B;
    case 'C': return C;
    case 'D': return D;
    case 'E': return E;
    case 'F': return F;
    case 'G': return G;
    case 'H': return H;
    case 'I': return I;
    case 'J': return J;
    case 'K': return K;
    case 'L': return L;
    case 'M': return M;
    case 'N': return N;
    case 'O': return O;
    case 'P': return P;
    case 'Q': return Q;
    case 'R': return R;
    case 'S': return S;
    case 'T': return T;
    case 'U': return U;
    case 'V': return V;
    case 'W': return W;
    case 'X': return X;
    case 'Y': return Y;
    case 'Z': return Z;
    case ' ': return space;
    default: return NULL;
  }
}


// Функция отображения одного столбца матрицы на определённой позиции
void matrix_display_column(unsigned char data, int column) {
  if (column >= 0 && column < 16) {  // Убедитесь, что колонка находится в пределах матрицы
    IIC_start();  
    IIC_send(0xC0 | column);  // Адресуем колонку
    IIC_send(data);           // Отправляем данные для этой колонки
    IIC_end();  
  }
}


// Функция прокрутки текста на матрице
void scrollText(String text) {
  int textLength = text.length();
  int scrollPos = 0;
  int spaceBetween = 2; // Задайте желаемое расстояние между символами
  
  // Прокручиваем до тех пор, пока последний символ не выйдет за левую границу
  while (scrollPos < textLength * (8 + spaceBetween) + 16) {  
    matrix_clear();  // Очищаем дисплей перед каждым обновлением


    for (int i = 0; i < textLength; i++) {
      char c = text[i];
      unsigned char* pattern = getCharPattern(c);
      
      // Рассчитываем смещение символа
      int charPos = 16 - (scrollPos - i * 5);
      
      // Выводим символ, если он находится в пределах видимой части матрицы
      if (charPos >= -8 && charPos < 16) {
        for (int col = 0; col < 8; col++) {
          matrix_display_column(pattern[col], charPos + col);
        }
      }
    }
    
    scrollPos++;  // Сдвиг текста влево
    delay(200);   // Задержка для эффекта прокрутки
  }
}


// Функция для очистки матрицы
void matrix_clear() {
  for (int i = 0; i < 16; i++) {
    matrix_display_column(0x00, i);  // Очищаем каждый столбец
  }
}


void setup() {
  pinMode(SCL_Pin, OUTPUT);
  pinMode(SDA_Pin, OUTPUT);
  IIC_start();
  IIC_send(0x8A);  // Контроль дисплея, установка ширины импульса на 4/16 s
  IIC_end();
}


void loop() {
  scrollText("LEO AND STEPHANIE");  // Пример текста для прокрутки
}



//the condition to start conveying data
void IIC_start()
{
  digitalWrite(SCL_Pin,HIGH);
  delayMicroseconds(3);
  digitalWrite(SDA_Pin,HIGH);
  delayMicroseconds(3);
  digitalWrite(SDA_Pin,LOW);
  delayMicroseconds(3);
}
//Convey data
void IIC_send(unsigned char send_data)
{
  for(char i = 0;i < 8;i++)  //Each byte has 8 bits 8bit for every character
  {
      digitalWrite(SCL_Pin,LOW);  // pull down clock pin SCL_Pin to change the signal of SDA
      delayMicroseconds(3);
      if(send_data & 0x01)  //set high and low level of SDA_Pin according to 1 or 0 of every bit
      {
        digitalWrite(SDA_Pin,HIGH);
      }
      else
      {
        digitalWrite(SDA_Pin,LOW);
      }
      delayMicroseconds(3);
      digitalWrite(SCL_Pin,HIGH); //pull up the clock pin SCL_Pin to stop transmission
      delayMicroseconds(3);
      send_data = send_data >> 1;  // detect bit by bit, shift the data to the right by one
  }
}

//The sign of ending data transmission
void IIC_end()
{
  digitalWrite(SCL_Pin,LOW);
  delayMicroseconds(3);
  digitalWrite(SDA_Pin,LOW);
  delayMicroseconds(3);
  digitalWrite(SCL_Pin,HIGH);
  delayMicroseconds(3);
  digitalWrite(SDA_Pin,HIGH);
  delayMicroseconds(3);
}
